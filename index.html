<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
  <script src="/socket.io/socket.io.js" charset="utf-8"></script>
  <!--<script src="//cdn.webrtc-experiment.com/DataChannel.js"> </script>-->
  <script src="https://cdn.webrtc-experiment.com:443/rmc3.min.js"></script>
  <script src="/reliable-signaler/signaler.js" charset="utf-8"></script>
  </head>
  <body>
    <input id='broadcastId' type="text"></input>
    <button id="ojbtn">OJBTN</button>
    <div id="videos-container"></div>
  </body>
  <script type="text/javascript">
    //var channel = new DataChannel();
    var connection = new RTCMultiConnection();

    var createRoom = function(connection,roomid) {
      /*signaler.createNewRoomOnServer(roomid,function(){
        chan.channel = chan.userid = roomid;
        chan.open(roomid);
        console.log('Created Room :',roomid);
      });*/
    connection.channel = connection.sessionid = connection.userid = roomid;//TODO:ddd
    connection.open({
        onMediaCaptured: function() {
        signaler.createNewRoomOnServer(connection.sessionid);
        }
      });
    };
    var signaler = initReliableSignaler(connection,'/');
    /*channel.ondatachannel = function(data_channel) {
      document.querySelector('h2').innerHTML += data_channel;
      console.log(data_channel);
    }*/
    //createRoom(channel,document.findElementById('roomid').text);
    var onMessageCallbacks = {};
    signaler.socket.on('scalable-broadcast-message', function(msg) {
      if(msg.sender==connections.userid) return;
      if(onMessageCallbacks[msg.channel]){
        onMessageCallbacks[msg.channel](msg.message);
      };
    });
    function initRTCMultiConnection(userid) {
                var connection = new RTCMultiConnection();
                document.getElementById('broadcastId').value = connection.token();
                connection.body = document.getElementById('videos-container');
                connection.channel = connection.sessionid = connection.userid = userid || connection.userid;
                connection.sdpConstraints.mandatory = {
                    OfferToReceiveAudio: true,
                    OfferToReceiveVideo: true
                };
                connection.openSignalingChannel = function(config) {
                    var channel = config.channel || this.channel;
                    onMessageCallbacks[channel] = config.onmessage;
                    if (config.onopen) setTimeout(config.onopen, 1000);
                    return {
                        send: function(message) {
                            signaler.socket.emit('scalable-broadcast-message', {
                                sender: connection.userid,
                                channel: channel,
                                message: message
                            });
                        },
                        channel: channel
                    };
                };
              return connection;
            }

  var connection = initRTCMultiConnection();
  connection.getExternalIceServers = false;

  connection.onstream = function(event) {
    connection.body.appendChild(event.mediaElement);

    if(connection.isInitiator == false && !connection.broadcastingConnection) {
      connection.broadcastingConnection = initRTCMultiConnection(connection.userid);
      connection.broadcastingConnection.onstream = function() {}; //Had to do because lib says there is a chrom bug
      connection.broadcastingConnection.session = connection.session;
      connection.broadcastingConnection.attachStreams.push(event.stream);
      connection.broadcastingConnection.dontCaptureUserMedia = true;
      connection.broadcastingConnection.sdpConstraints.mandatory = {
          OfferToReceiveVideo: false,
          OfferToReceiveAudio: false
      };
      connection.broadcastingConnection.open({
          dontTransmit: true
      });
    }
  };
  document.getElementById('ojbtn').onclick = function() {
    var broadcastId = document.getElementById('broadcastId').value;
    if (broadcastId.replace(/^\s+|\s+$/g, '').length <= 0) {
        alert('Input broadcast-id');
        document.getElementById('broadcastId').focus();
        return;
    }
    console.log(broadcastId.value);
    this.disables = true;
    connection.session = {
      video: 1,
      audio: 2
    };

      signaler.socket.emit('join-broadcast', {
        broadcastid: broadcastId,
        userid: connection.userid,
        typeofStreams: connection.session
        });
    };
    signaler.socket.on('join-broadcaster', function(hintsToJoinBroadcast) {
        connection.session = hintsToJoinBroadcast.typeOfStreams;
        connection.channel = connection.sessionid = hintsToJoinBroadcast.userid;
        connection.sdpConstraints.mandatory = {
            OfferToReceiveVideo: connection.session.video, //!!
            OfferToReceiveAudio: connection.session.audio //!!
        };
        connection.join({
            sessionid: hintsToJoinBroadcast.userid,
            userid: hintsToJoinBroadcast.userid,
            extra: {},
            session: connection.session
        });
    });
    signaler.socket.on('join-broadcaster', function(hintsToJoinBroadcast) {
        connection.session = hintsToJoinBroadcast.typeOfStreams;
        connection.channel = connection.sessionid = hintsToJoinBroadcast.userid;
        connection.sdpConstraints.mandatory = {
            OfferToReceiveVideo: !!connection.session.video,
            OfferToReceiveAudio: !!connection.session.audio
        };
        connection.join({
            sessionid: hintsToJoinBroadcast.userid,
            userid: hintsToJoinBroadcast.userid,
            extra: {},
            session: connection.session
        });
    });
    signaler.socket.on('start-broadcasting', function(typeOfStreams) {
        // host i.e. sender should always use this!
        connection.sdpConstraints.mandatory = {
            OfferToReceiveVideo: true,
            OfferToReceiveAudio: true
        };
        connection.session = typeOfStreams;
        connection.open({
            dontTransmit: true
        });
        if (connection.broadcastingConnection) {
            // if new person is given the initiation/host/moderation control
            connection.broadcastingConnection.close();
            connection.broadcastingConnection = null;
        }
    });
    window.onbeforeunload = function() {
    // Firefox ke nakhre :P :D
    document.getElementById('ojbtn').disabled = false;
  };
  </script>
</html>
